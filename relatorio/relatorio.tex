\documentclass[11pt]{article}   % tipo de documento e tamanho das letras

% os seguintes pacotes estendem a funcionalidade básica:
\usepackage[a4paper, total={16cm, 24cm}]{geometry} % tamanho da pagina e do texto
\usepackage[portuguese]{babel}  % traduz para portugues
\usepackage[utf8]{inputenc}
\usepackage{graphicx}           % graficos
\usepackage{amsmath}            % matematica
\usepackage{tikz}               % diagramas
    \usetikzlibrary{shadows}
\usepackage{booktabs}           % tabelas com  melhor aspecto
\usepackage[colorlinks=true]{hyperref}           % links para partes do documento ou para a web
\usepackage{listings}           % incluir codigo
    \renewcommand\lstlistingname{Listagem}  % Listing em portugues
    \lstset{numbers=left, numberstyle=\tiny, numbersep=5pt, basicstyle=\footnotesize\ttfamily, frame=tb,rulesepcolor=\color{gray}, breaklines=true}
\usepackage{blindtext}

% -------------------------------------------------------------------------------------------
\title
{
    \includegraphics[width=0.3\textwidth]{images/logo_universidade.png}
    \\[0.1cm]
    \textbf{Códigos Ambíguos} \\
    Programação III
}

\author
{
    \textbf{Professores:} Salvador Abreu \\ Pedro Patinho \\
    \textbf{Realizado por:} Miguel de Carvalho (43108) \\ João Pereira (42864) 
}
\date{\today}

% -------------------------------------------------------------------------------------------
%                                Body                                                       %
% -------------------------------------------------------------------------------------------

\begin{document}
\maketitle

% -------------------------------------------------------------------------------------------
\section{Introdução} 
\hspace{0,5cm}Neste trabalho foi solicitado a realização de um programa que encontre 
\textbf{Palavras Ambíguas} numa gramática binária, como representado na figura abaixo.

\begin{figure}[h!]
    \begin{center}
        \includegraphics[width=0.5\textwidth]{images/gramatica.png}
        \caption{Exemplo de uma grmática binária}
    \end{center}
\end{figure}

% -------------------------------------------------------------------------------------------
\section{Implementação}

\hspace{0,5cm}Inicialmente pensámos como deveríamos proceder para realizar o trabalho, ou seja,
começámos por fazer o "pensamento" em papel. 

De seguida na nossa primeira tentativa começamos por implementar tudo em \textbf{Prolog}, mas 
chegamos à conclusão de que o nosso pensamento seria necessário ser feito na linguagem \textbf{OCaml}.

Então na nossa segunda tentativa
% -------------------------------------------------------------------------------------------
\section{Funções}

\subsection{Funções Auxiliares}

\begin{itemize}
    \item \verb|getWord| - recebe um \textbf{tuplo} e devolve a 2ª posição (\textbf{word});
    \item \verb|getBin| - recebe um \textbf{tuplo} e devolve a 1ª posição (\textbf{binário});
    \item \verb|convert| - recebe um \textbf{tuplo} em que a 1ª posição é um \textbf{char} e 
    converte essa 1ª posição do \textbf{tuplo} em uma \textbf{lista} que contem uma \textbf{string}
    e devolve esse \textbf{tuplo} modificado;
    \item \verb|convertList| - recebe uma \textbf{lista} de \textbf{tuplos} e utiliza o \verb|convert|
    em cada um dos seus \textbf{tuplos} e devolve essa \textbf{lista} convertida;
    \item \verb|printWord| - recebe uma \textbf{lista} de \textbf{strings} (\textbf{words}) e 
    \textit{printa} usando a função \verb|print_string|;
    \item \verb|printBin| - recebe uma \textbf{lista} de \textbf{inteiros} (\textbf{bins}) e 
    \textit{printa} usando a função \verb|print_int|;
    \item \verb|printWordList| - recebe uma \textbf{lista} de \textbf{tuplos} e \textit{printa} só a 
    \textbf{words} usando a função \verb|getWord| e \verb|printWord|;
    \item \verb|printBinList| - recebe uma \textbf{lista} de \textbf{tuplos} e \textit{printa} só as 
    \textbf{bins} usando a função \textit{getBin} e \textit{printBin};
    \item \verb|printCodeList| - recebe uma \verb|lista| de \verb|tuplos| e \textit{printa} o conteúdo
    utilizando o \verb|printWordList| e \verb|printBinList|;
    \item \verb|merge| - recebe dois \textbf{tuplos} cada um com a \textbf{word} e o respetivo \textbf{bin}
    e faz \textit{append} (\verb|@|) devolvendo um único \textbf{tuplo} com a junção das \textbf{words} e 
    do respetivo \textbf{bin};
    \item \verb|listHeader| - recebe uma \textbf{lista} e retorna o \textbf{topo} dessa \textbf{lista};
\end{itemize}

\subsection{Funções Principais}

\begin{itemize}
    \item \verb|main| - recebe uma \textbf{lista} de \textbf{tuplos convertidos} pela função 
    \verb|convertList| e retorna \verb|is_ambi|;
    \item \verb|is_ambigous| - recebe uma \textbf{lista} de \textbf{tuplos} e verifica se os 
    \textbf{bins} dessa \textbf{lista} correspondem a mais do que uma \textbf{word} utilizando 
    a função \verb|process|. Caso não seja, retorna uma \textbf{lista vazia}, caso contrário, 
    devolve a resposta da ambiguidade;
    \item \verb|loop_merge| - recebe uma \textbf{lista convertida} e uma \textbf{lista vazia};
    \item \verb|list_merge| - recebe duas \textbf{listas} e retorna uma \textbf{lista} com o 
    conteúdo das duas \textbf{listas} sem existir repetição;
\end{itemize}

% -------------------------------------------------------------------------------------------
\section{Conclusão} % Conclusão
\hspace{0,5cm}Em suma, com a realização deste trabalho "Códigos Ambíguos" fiquei muito mais esclarecido sobre o seu funcionamento. \par
Saliento que me ajudou a entender como funciona o escalonador e as condições que cada algoritmo (\textbf{FCFS}/\textbf{RR}), usa para proceder à mudança dos processos entre os estados e as respetivas diferenças de tempo no mesmo conjunto de processos, entre os respetivos algoritmos.
% -------------------------------------------------------------------------------------------
\end{document}